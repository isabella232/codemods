// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`inputs decimal.js 1`] = `
import { PrismaClient, Prisma } from '@prisma/client';

async function main() {
  const prisma = new PrismaClient()

  const a = await prisma.a.findFirst()
  const b = await prisma.b.findFirst({
    where: {
      decFloat: new Prisma.Decimal('1.23')
    }
  })
  const c = await prisma.c.findFirst()
  const d = await prisma.d.findFirst()
  const e = await prisma.e.findFirst()

}

main()

`;

exports[`inputs decimal.ts 1`] = `
import { PrismaClient, Prisma } from '@prisma/client';

async function main() {
  const prisma = new PrismaClient()

  const a: null | {
    id: string
    email: string
    name: string | null
    int: number
    sInt: number
    bInt: BigInt
    serial: number
    sSerial: number
    bSerial: number
    inc_int: number
    inc_sInt: number
    inc_bInt: BigInt
  } = await prisma.a.findFirst()
  const b = await prisma.b.findFirst({
    where: {
      decFloat: new Prisma.Decimal('1.23')
    }
  })
  const c = await prisma.c.findFirst()
  const d: null | {
    id: string
    bool: boolean
    byteA: Buffer
    xml: string
    json: Prisma.JsonValue
    jsonb: Prisma.JsonValue
  } = await prisma.d.findFirst()
  const e = await prisma.e.findFirst()

}

main()

`;

exports[`inputs errorImports.ts 1`] = `
const {
  Prisma,
  PrismaClient
} = require('./node_modules/@prisma/client')

test('blog', async () => {
  const requests: any[] = []
  const db = new PrismaClient({
    errorFormat: 'colorless',
    __internal: {
      hooks: {
        beforeRequest: (request) => requests.push(request),
      },
    },
  })

  if (!Prisma.prismaVersion || !Prisma.prismaVersion.client) {
    throw new Error(\`prismaVersion missing: \${JSON.stringify(Prisma.prismaVersion)}\`)
  }

  // Test connecting and disconnecting all the time
  await db.user.findMany()
  const posts = await db.user
    .findOne({
      where: {
        email: 'a@a.de',
      },
    })
    .posts()

  expect(posts.length).toBe(0)
  db.$disconnect()
  expect(requests.length).toBe(2)

  await db.user.findMany()
  db.$disconnect()
  expect(requests.length).toBe(3)

  const count = await db.user.count()
  expect(typeof count === 'number').toBe(true)

  const paramCount = await db.user.count({
    take: 10000,
  })

  expect(typeof paramCount === 'number').toBe(true)

  db.$connect()
  await db.$disconnect()

  await new Promise((r) => setTimeout(r, 200))
  db.$connect()

  const userPromise = db.user.findMany()
  await userPromise
  // @ts-ignore

  await db.$disconnect()

  await db.$connect()

  /**
   * queryRaw
   */

  // Test queryRaw(string)
  const rawQuery = await db.$queryRaw('SELECT 1')
  expect(rawQuery[0]['1']).toBe(1)

  // Test queryRaw(string, values)
  const rawQueryWithValues = await db.$queryRaw(
    'SELECT $1 AS name, $2 AS id',
    'Alice',
    42,
  )

  expect(rawQueryWithValues[0]).toEqual({
    name: 'Alice',
    id: 42,
  })

  // Test queryRaw\`\`
  const rawQueryTemplate = await db.$queryRaw\`SELECT 1\`
  expect(rawQueryTemplate[0]['1']).toBe(1)

  // Test queryRaw\`\` with \${param}
  const rawQueryTemplateWithParams = await db.$queryRaw\`SELECT * FROM User WHERE name = \${'Alice'}\`
  expect(rawQueryTemplateWithParams[0].name).toBe('Alice')

  // Test queryRaw\`\` with prisma.sql\`\`
  const rawQueryTemplateFromSqlTemplate = await db.$queryRaw(
    Prisma.sql\`
      SELECT \${Prisma.join([Prisma.raw('email'), Prisma.raw('id'), Prisma.raw('name')])}
      FROM \${Prisma.raw('User')}
      \${Prisma.sql\`WHERE name = \${'Alice'}\`}
      \${Prisma.empty}
    \`,
  )
  expect(rawQueryTemplateFromSqlTemplate[0].name).toBe('Alice')

  /**
   * .$executeRaw(
   */

  // Test .$executeRaw((string)
  const executeRaw = await db.$executeRaw(
    'UPDATE User SET name = $1 WHERE id = $2',
    'name',
    'id',
  )
  expect(executeRaw).toBe(0)

  // Test .$executeRaw((string, values)
  const executeRawWithValues = await db.$executeRaw(
    'UPDATE User SET name = $1 WHERE id = $2',
    'Alice',
    'id',
  )
  expect(executeRawWithValues).toBe(0)

  // Test $executeRaw
  const $executeRawTemplate = await db.$executeRaw\`UPDATE User SET name = \${'name'} WHERE id = \${'id'}\`
  expect($executeRawTemplate).toBe(0)

  // Test validation errors
  let validationError
  try {
    await db.post.create({
      data: {},
    })
  } catch (e) {
    validationError = e
  } finally {
    if (
      !validationError ||
      !(validationError instanceof Prisma.PrismaClientValidationError)
    ) {
      throw new Error(\`Validation error is incorrect\`)
    }
  }

  // Test known request error
  let knownRequestError
  try {
    const result = await db.user.create({
      data: {
        email: 'a@a.de',
        name: 'Alice',
      },
    })
  } catch (e) {
    knownRequestError = e
  } finally {
    if (
      !knownRequestError ||
      !(knownRequestError instanceof Prisma.PrismaClientKnownRequestError)
    ) {
      throw new Error(\`Known request error is incorrect\`)
    } else {
      if (!knownRequestError.message.includes('.user.create()')) {
        throw new Error(\`Invalid error: \${knownRequestError.message}\`)
      }
    }
  }

  // relation query where not null
  const relationWhereNotNull = await db.user.findMany({
    where: {
      profile: {
        bio: { not: null },
      },
    },
  })
  expect(relationWhereNotNull).toEqual([])

  db.$disconnect()
})

`;

exports[`inputs keyof.ts 1`] = `
import { PrismaClient, Prisma } from '@prisma/client';
type X = Required<Prisma.UserArgs>
type Y = {
  hello: Prisma.UserArgs
}
type Z = {
  [T in keyof Prisma.UserArgs]: Prisma.UserArgs[T]
}[keyof Prisma.UserArgs]

function a(a: Prisma.UserArgs): Prisma.UserArgs {
  return null as any
}
function b<T extends Prisma.UserArgs>() {
}
async function main() {
  const prisma = new PrismaClient()
  await prisma.user.update({
    where: {
    },
    data: {
      posts: {
      }
    }
  })
  prisma.$disconnect()
}
main()
`;

exports[`inputs minimal.ts 1`] = `
import { Prisma, PrismaClient } from '@prisma/client'
import * as fs from 'fs'
function test(){
    const why = fs
}
// in the code
const args: Prisma.UserArgs
`;

exports[`inputs sql.ts 1`] = `
import { PrismaClient, Prisma } from '@prisma/client';

// tslint:disable

// This file will not be executed, just compiled to check if the typings are valid
async function main() {
  const prisma = new PrismaClient({
    log: [
      {
        emit: 'event',
        level: 'query',
      },
    ],
    datasources: {
      db: {
        url: 'file:dev.db',
      },
    },
  })

  prisma.on('query', (a) => {
    //
  })

  Prisma.prismaVersion.client

  const x: Prisma.Sql = Prisma.sql\`SELECT * FROM \${Prisma.raw('User')} WHERE 'id' in \${Prisma.join([
    1,
    2,
    3,
  ])} \${Prisma.empty} \`

  const queryRaw1 = await prisma.$queryRaw\`SELECT * FROM User WHERE id = 1\`
  const queryRaw2 = await prisma.$queryRaw\`SELECT * FROM User WHERE id = \${1}\`
  const queryRaw3 = await prisma.$queryRaw(
    \`SELECT * FROM User WHERE id = $1\`,
    2,
  )
  const queryRaw4 = await prisma.$queryRaw(
    Prisma.sql\`SELECT * FROM User WHERE id = \${1}\`,
  )
  const queryRaw5 = await prisma.$queryRaw(
    Prisma.sql\`SELECT * FROM User \${Prisma.sql\`WHERE id = \${1}\`}\`,
  )

  const executeRaw1 = await prisma.$executeRaw\`SELECT * FROM User WHERE id = 1\`
  const executeRaw2 = await prisma.$executeRaw\`SELECT * FROM User WHERE id = \${1}\`
  const executeRaw3 = await prisma.$executeRaw(
    \`SELECT * FROM User WHERE id = $1\`,
    2,
  )
  const executeRaw4 = await prisma.$executeRaw(
    Prisma.sql\`SELECT * FROM User WHERE id = \${1}\`,
  )
  const executeRaw5 = await prisma.$executeRaw(
    Prisma.sql\`SELECT * FROM User \${Prisma.sql\`WHERE id = \${1}\`}\`,
  )

  const result1 = await prisma.user.findMany({
    where: {
      posts: {
        some: {
          author: {
            AND: {
              id: '5',
              posts: {
                some: {
                  author: {
                    posts: {
                      some: {
                        title: '5',
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
  })

  result1[0]!.email
  result1[0]!.id
  result1[0]!.name

  const result2: {
    id: string
    createdAt: Date
    updatedAt: Date
    published: boolean
    title: string
    content: string | null
    author: Prisma.User | null
  } | null = await prisma.post.findOne({
    where: {
      id: '',
    },
    include: {
      author: true,
    },
  })

  const result3: 'Please either choose \`select\` or \`include\`' = await prisma.post.findMany(
    {
      select: {},
      include: {},
    },
  )

  const result4: Array<{
    id: string
    author: {
      name: string | null
    } | null
  }> = await prisma.post.findMany({
    select: {
      id: true,
      author: {
        select: {
          name: true,
        },
      },
    },
  })

  const result5: Prisma.Post = await prisma.post.create({
    data: {
      published: false,
      title: 'Title',
    },
  })

  await prisma.post.delete({
    where: {
      id: '',
    },
  })

  await prisma.post.upsert({
    create: {
      published: false,
      title: 'Title',
    },
    update: {
      published: true,
    },
    where: {
      id: '6',
    },
  })

  await prisma.post.updateMany({
    data: {
      published: false,
    },
  })

  const count: number = await prisma.post.count({
    where: {
      published: false,
    },
  })

  const $disconnect: Promise<void> = prisma.$disconnect()

  // Trick to define a "positive" test, if "include" is NOT in "FindManyMachineDataArgs"
  type X = keyof Prisma.FindManyMachineDataArgs
  type Y = 'include' extends X ? number : string
  const y: Y = 'string'

  // Test for https://github.com/prisma/prisma-client-js/issues/615
  const users = await prisma.user.findMany({
    include: {
      posts: {
        include: {
          author: true,
        },
        orderBy: {
          title: 'asc',
        },
      },
    },
  })

  const id = users[0].posts[0].author?.id

  const like = await prisma.like.findOne({
    where: {
      userId_postId: {
        postId: '',
        userId: '',
      },
    },
    include: { post: true },
  })

  like!.post

  const like2 = await prisma.like.upsert({
    where: {
      userId_postId: {
        userId: '',
        postId: '',
      },
    },
    create: {
      post: { connect: { id: '' } },
      user: { connect: { id: '' } },
    },
    update: {},
    include: { post: true },
  })

  like2!.post

  // make sure, that null is not allowed for this type
  type LikeUpdateIdType = Prisma.LikeUpdateManyArgs['data']['id']
  type AllowsNull = null extends LikeUpdateIdType ? true : false
  const allowsNull: AllowsNull = false

  // check if listing of \`set\` is done in nested relations
  // https://github.com/prisma/prisma/issues/3497
  await prisma.user.update({
    where: {
      id: '6',
    },
    data: {
      posts: {
        update: {
          data: {
            title: 'something',
          },
          where: {
            id: 'whatever',
          },
        },
      },
    },
  })

  await prisma.user.update({
    where: {
      id: '6',
    },
    data: {
      posts: {
        updateMany: {
          data: {
            title: 'something',
          },
          where: {
            id: 'whatever',
          },
        },
      },
    },
  })

  await prisma.post.update({
    where: {
      id: '6',
    },
    data: {
      author: {
        update: {
          name: 'something',
        },
      },
    },
  })
}

main().catch((e) => {
  console.error(e)
})

`;

exports[`projects minimal 1`] = `
import { PrismaClient, Prisma } from './generated/client';

// tslint:disable

// This file will not be executed, just compiled to check if the typings are valid
async function main() {
  const prisma = new PrismaClient({
    log: [
      {
        emit: 'event',
        level: 'query',
      },
    ],
    datasources: {
      db: {
        url: 'file:dev.db',
      },
    },
  })

  prisma.on('query', (a) => {
    //
  })

  Prisma.prismaVersion.client

  const x: Prisma.Sql = Prisma.sql\`SELECT * FROM \${Prisma.raw('User')} WHERE 'id' in \${Prisma.join([
    1,
    2,
    3,
  ])} \${Prisma.empty} \`

  const queryRaw1 = await prisma.$queryRaw\`SELECT * FROM User WHERE id = 1\`
  const queryRaw2 = await prisma.$queryRaw\`SELECT * FROM User WHERE id = \${1}\`
  const queryRaw3 = await prisma.$queryRaw(
    \`SELECT * FROM User WHERE id = $1\`,
    2,
  )
  const queryRaw4 = await prisma.$queryRaw(
    Prisma.sql\`SELECT * FROM User WHERE id = \${1}\`,
  )
  const queryRaw5 = await prisma.$queryRaw(
    Prisma.sql\`SELECT * FROM User \${Prisma.sql\`WHERE id = \${1}\`}\`,
  )

  const executeRaw1 = await prisma.$executeRaw\`SELECT * FROM User WHERE id = 1\`
  const executeRaw2 = await prisma.$executeRaw\`SELECT * FROM User WHERE id = \${1}\`
  const executeRaw3 = await prisma.$executeRaw(
    \`SELECT * FROM User WHERE id = $1\`,
    2,
  )
  const executeRaw4 = await prisma.$executeRaw(
    Prisma.sql\`SELECT * FROM User WHERE id = \${1}\`,
  )
  const executeRaw5 = await prisma.$executeRaw(
    Prisma.sql\`SELECT * FROM User \${Prisma.sql\`WHERE id = \${1}\`}\`,
  )

  const result1 = await prisma.user.findMany({
    where: {
      posts: {
        some: {
          author: {
            AND: {
              id: '5',
              posts: {
                some: {
                  author: {
                    posts: {
                      some: {
                        title: '5',
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
  })

  result1[0]!.email
  result1[0]!.id
  result1[0]!.name

  const result2: {
    id: string
    createdAt: Date
    updatedAt: Date
    published: boolean
    title: string
    content: string | null
    author: Prisma.User | null
  } | null = await prisma.post.findOne({
    where: {
      id: '',
    },
    include: {
      author: true,
    },
  })

  const result3: 'Please either choose \`select\` or \`include\`' = await prisma.post.findMany(
    {
      select: {},
      include: {},
    },
  )

  const result4: Array<{
    id: string
    author: {
      name: string | null
    } | null
  }> = await prisma.post.findMany({
    select: {
      id: true,
      author: {
        select: {
          name: true,
        },
      },
    },
  })

  const result5: Prisma.Post = await prisma.post.create({
    data: {
      published: false,
      title: 'Title',
    },
  })

  await prisma.post.delete({
    where: {
      id: '',
    },
  })

  await prisma.post.upsert({
    create: {
      published: false,
      title: 'Title',
    },
    update: {
      published: true,
    },
    where: {
      id: '6',
    },
  })

  await prisma.post.updateMany({
    data: {
      published: false,
    },
  })

  const count: number = await prisma.post.count({
    where: {
      published: false,
    },
  })

  const $disconnect: Promise<void> = prisma.$disconnect()

  // Trick to define a "positive" test, if "include" is NOT in "FindManyMachineDataArgs"
  type X = keyof Prisma.FindManyMachineDataArgs
  type Y = 'include' extends X ? number : string
  const y: Y = 'string'

  // Test for https://github.com/prisma/prisma-client-js/issues/615
  const users = await prisma.user.findMany({
    include: {
      posts: {
        include: {
          author: true,
        },
        orderBy: {
          title: 'asc',
        },
      },
    },
  })

  const id = users[0].posts[0].author?.id

  const like = await prisma.like.findOne({
    where: {
      userId_postId: {
        postId: '',
        userId: '',
      },
    },
    include: { post: true },
  })

  like!.post

  const like2 = await prisma.like.upsert({
    where: {
      userId_postId: {
        userId: '',
        postId: '',
      },
    },
    create: {
      post: { connect: { id: '' } },
      user: { connect: { id: '' } },
    },
    update: {},
    include: { post: true },
  })

  like2!.post

  // make sure, that null is not allowed for this type
  type LikeUpdateIdType = Prisma.LikeUpdateManyArgs['data']['id']
  type AllowsNull = null extends LikeUpdateIdType ? true : false
  const allowsNull: AllowsNull = false

  // check if listing of \`set\` is done in nested relations
  // https://github.com/prisma/prisma/issues/3497
  await prisma.user.update({
    where: {
      id: '6',
    },
    data: {
      posts: {
        update: {
          data: {
            title: 'something',
          },
          where: {
            id: 'whatever',
          },
        },
      },
    },
  })

  await prisma.user.update({
    where: {
      id: '6',
    },
    data: {
      posts: {
        updateMany: {
          data: {
            title: 'something',
          },
          where: {
            id: 'whatever',
          },
        },
      },
    },
  })

  await prisma.post.update({
    where: {
      id: '6',
    },
    data: {
      author: {
        update: {
          name: 'something',
        },
      },
    },
  })
}

main().catch((e) => {
  console.error(e)
})

import { PrismaClient, Prisma } from '../generated/client';

// tslint:disable

// This file will not be executed, just compiled to check if the typings are valid
async function main() {
  const prisma = new PrismaClient({
    log: [
      {
        emit: 'event',
        level: 'query',
      },
    ],
    datasources: {
      db: {
        url: 'file:dev.db',
      },
    },
  })

  prisma.on('query', (a) => {
    //
  })

  Prisma.prismaVersion.client

  const x: Prisma.Sql = Prisma.sql\`SELECT * FROM \${Prisma.raw('User')} WHERE 'id' in \${Prisma.join([
    1,
    2,
    3,
  ])} \${Prisma.empty} \`

  const queryRaw1 = await prisma.$queryRaw\`SELECT * FROM User WHERE id = 1\`
  const queryRaw2 = await prisma.$queryRaw\`SELECT * FROM User WHERE id = \${1}\`
  const queryRaw3 = await prisma.$queryRaw(
    \`SELECT * FROM User WHERE id = $1\`,
    2,
  )
  const queryRaw4 = await prisma.$queryRaw(
    Prisma.sql\`SELECT * FROM User WHERE id = \${1}\`,
  )
  const queryRaw5 = await prisma.$queryRaw(
    Prisma.sql\`SELECT * FROM User \${Prisma.sql\`WHERE id = \${1}\`}\`,
  )

  const executeRaw1 = await prisma.$executeRaw\`SELECT * FROM User WHERE id = 1\`
  const executeRaw2 = await prisma.$executeRaw\`SELECT * FROM User WHERE id = \${1}\`
  const executeRaw3 = await prisma.$executeRaw(
    \`SELECT * FROM User WHERE id = $1\`,
    2,
  )
  const executeRaw4 = await prisma.$executeRaw(
    Prisma.sql\`SELECT * FROM User WHERE id = \${1}\`,
  )
  const executeRaw5 = await prisma.$executeRaw(
    Prisma.sql\`SELECT * FROM User \${Prisma.sql\`WHERE id = \${1}\`}\`,
  )

  const result1 = await prisma.user.findMany({
    where: {
      posts: {
        some: {
          author: {
            AND: {
              id: '5',
              posts: {
                some: {
                  author: {
                    posts: {
                      some: {
                        title: '5',
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
  })

  result1[0]!.email
  result1[0]!.id
  result1[0]!.name

  const result2: {
    id: string
    createdAt: Date
    updatedAt: Date
    published: boolean
    title: string
    content: string | null
    author: Prisma.User | null
  } | null = await prisma.post.findOne({
    where: {
      id: '',
    },
    include: {
      author: true,
    },
  })

  const result3: 'Please either choose \`select\` or \`include\`' = await prisma.post.findMany(
    {
      select: {},
      include: {},
    },
  )

  const result4: Array<{
    id: string
    author: {
      name: string | null
    } | null
  }> = await prisma.post.findMany({
    select: {
      id: true,
      author: {
        select: {
          name: true,
        },
      },
    },
  })

  const result5: Prisma.Post = await prisma.post.create({
    data: {
      published: false,
      title: 'Title',
    },
  })

  await prisma.post.delete({
    where: {
      id: '',
    },
  })

  await prisma.post.upsert({
    create: {
      published: false,
      title: 'Title',
    },
    update: {
      published: true,
    },
    where: {
      id: '6',
    },
  })

  await prisma.post.updateMany({
    data: {
      published: false,
    },
  })

  const count: number = await prisma.post.count({
    where: {
      published: false,
    },
  })

  const $disconnect: Promise<void> = prisma.$disconnect()

  // Trick to define a "positive" test, if "include" is NOT in "FindManyMachineDataArgs"
  type X = keyof Prisma.FindManyMachineDataArgs
  type Y = 'include' extends X ? number : string
  const y: Y = 'string'

  // Test for https://github.com/prisma/prisma-client-js/issues/615
  const users = await prisma.user.findMany({
    include: {
      posts: {
        include: {
          author: true,
        },
        orderBy: {
          title: 'asc',
        },
      },
    },
  })

  const id = users[0].posts[0].author?.id

  const like = await prisma.like.findOne({
    where: {
      userId_postId: {
        postId: '',
        userId: '',
      },
    },
    include: { post: true },
  })

  like!.post

  const like2 = await prisma.like.upsert({
    where: {
      userId_postId: {
        userId: '',
        postId: '',
      },
    },
    create: {
      post: { connect: { id: '' } },
      user: { connect: { id: '' } },
    },
    update: {},
    include: { post: true },
  })

  like2!.post

  // make sure, that null is not allowed for this type
  type LikeUpdateIdType = Prisma.LikeUpdateManyArgs['data']['id']
  type AllowsNull = null extends LikeUpdateIdType ? true : false
  const allowsNull: AllowsNull = false

  // check if listing of \`set\` is done in nested relations
  // https://github.com/prisma/prisma/issues/3497
  await prisma.user.update({
    where: {
      id: '6',
    },
    data: {
      posts: {
        update: {
          data: {
            title: 'something',
          },
          where: {
            id: 'whatever',
          },
        },
      },
    },
  })

  await prisma.user.update({
    where: {
      id: '6',
    },
    data: {
      posts: {
        updateMany: {
          data: {
            title: 'something',
          },
          where: {
            id: 'whatever',
          },
        },
      },
    },
  })

  await prisma.post.update({
    where: {
      id: '6',
    },
    data: {
      author: {
        update: {
          name: 'something',
        },
      },
    },
  })
}

main().catch((e) => {
  console.error(e)
})

`;
